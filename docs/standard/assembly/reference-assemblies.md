---
title: Zestawy odwołań
description: Dowiedz się więcej na temat zestawów referencyjnych, specjalnego typu zestawów w programie .NET, które zawierają tylko publiczną powierzchnię interfejsu API biblioteki
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: f509397f5cb48a004b800014b2b071721e0d68b8
ms.sourcegitcommit: 1f12db2d852d05bed8c53845f0b5a57a762979c8
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/18/2019
ms.locfileid: "72582846"
---
# <a name="reference-assemblies"></a><span data-ttu-id="10022-103">Zestawy odwołań</span><span class="sxs-lookup"><span data-stu-id="10022-103">Reference assemblies</span></span>

<span data-ttu-id="10022-104">*Zestawy referencyjne* są specjalnym typem zestawu, który zawiera tylko minimalną ilość metadanych wymaganą do reprezentowania publicznej powierzchni interfejsu API biblioteki.</span><span class="sxs-lookup"><span data-stu-id="10022-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="10022-105">Obejmują one deklaracje dla wszystkich składowych, które są istotne w przypadku odwoływania się do zestawu w narzędziach kompilacji (w związku z czym nazwa), ale wyklucza wszystkie implementacje składowe, a także deklaracje członków prywatnych, którzy nie mają zauważalnego wpływu na ich kontrakt interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="10022-105">They include declarations for all members that are significant when referencing an assembly in build tools (hence the name), but exclude all member implementations as well as declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="10022-106">Z kolei regularne zestawy są nazywane *zestawami implementacji*.</span><span class="sxs-lookup"><span data-stu-id="10022-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span> 

<span data-ttu-id="10022-107">Nie można załadować zestawów referencyjnych do wykonania, ale mogą one być przesyłane jako dane wejściowe kompilatora w taki sam sposób jak zestawy implementacji.</span><span class="sxs-lookup"><span data-stu-id="10022-107">Reference assemblies cannot be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="10022-108">Zestawy referencyjne są zwykle dystrybuowane z zestawem Software Development Kit (SDK) określonej platformy lub biblioteki, specjalny składnik oprogramowania instalowany tylko na komputerach deweloperskich.</span><span class="sxs-lookup"><span data-stu-id="10022-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library, a special software component installed only on developer machines.</span></span>

<span data-ttu-id="10022-109">Użycie zestawu referencyjnego umożliwia deweloperom tworzenie programów przeznaczonych dla określonej wersji biblioteki bez konieczności używania pełnego zestawu implementacji dla tej wersji.</span><span class="sxs-lookup"><span data-stu-id="10022-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="10022-110">Załóżmy, że masz tylko najnowszą wersję niektórych bibliotek na swojej maszynie, ale chcesz skompilować program przeznaczony dla maszyny z wcześniejszą wersją tej biblioteki.</span><span class="sxs-lookup"><span data-stu-id="10022-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets a machine with an earlier version of that library.</span></span> <span data-ttu-id="10022-111">Jeśli kompilujesz bezpośrednio względem zestawu implementacji, możesz przypadkowo użyć elementów członkowskich interfejsu API, które nie są dostępne we wcześniejszej wersji, a podczas testowania programu na maszynie docelowej będzie można znaleźć tylko ten błąd.</span><span class="sxs-lookup"><span data-stu-id="10022-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version, and you'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="10022-112">Jeśli kompilujesz względem zestawu odwołań dla starszej wersji, natychmiast otrzymasz błąd w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="10022-112">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="10022-113">Ponadto zestaw referencyjny może reprezentować kontrakt, czyli zestaw interfejsów API, które nie odpowiadają zestawowi konkretnych implementacji.</span><span class="sxs-lookup"><span data-stu-id="10022-113">Additionally, a reference assembly can represent a contract, that is, a set of APIs that doesn't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="10022-114">Taki zestaw referencyjny, nazywany *zestawem kontraktu*, może służyć jako ukierunkowana na wiele platform, które obsługują ten sam zestaw interfejsów API.</span><span class="sxs-lookup"><span data-stu-id="10022-114">Such reference assembly, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="10022-115">Na przykład .NET Standard zawiera zestaw kontraktu, *plik. dll*, który reprezentuje zestaw wspólnych interfejsów API współużytkowanych przez różne platformy .NET.</span><span class="sxs-lookup"><span data-stu-id="10022-115">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="10022-116">Implementacje tych interfejsów API są zawarte w różnych zestawach na różnych platformach, takich jak *mscorlib. dll* w .NET Framework lub *System. private. CoreLib. dll* na platformie .NET Core.</span><span class="sxs-lookup"><span data-stu-id="10022-116">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="10022-117">Biblioteka, która jest przeznaczona dla .NET Standard można uruchamiać na wszystkich platformach, które obsługują .NET Standard.</span><span class="sxs-lookup"><span data-stu-id="10022-117">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span> 

## <a name="using-reference-assemblies"></a><span data-ttu-id="10022-118">Używanie zestawów odwołań</span><span class="sxs-lookup"><span data-stu-id="10022-118">Using reference assemblies</span></span>

<span data-ttu-id="10022-119">Aby używać niektórych interfejsów API z projektu, należy dodać odwołania do ich zestawów.</span><span class="sxs-lookup"><span data-stu-id="10022-119">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="10022-120">Można dodać odwołania do zestawów implementacji bezpośrednio lub do zestawów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="10022-120">You can add references either to implementation assemblies directly or to reference assemblies.</span></span> <span data-ttu-id="10022-121">Zdecydowanie zalecamy używanie zestawów referencyjnych, gdy są one dostępne, ponieważ takie działanie gwarantuje, że używasz tylko elementów członkowskich interfejsu API, które są obsługiwane w wersji docelowej i są przeznaczone do użytku przez projektantów interfejsów API (innymi słowy, nie podejmują zależności na temat szczegółów implementacji).</span><span class="sxs-lookup"><span data-stu-id="10022-121">We strongly recommend that you use reference assemblies whenever they are available, because doing so ensures that you are using only API members that are supported in the target version and are meant to be used by API designers (in other words, not taking a dependency on implementation details).</span></span>

<span data-ttu-id="10022-122">Zestawy referencyjne dla bibliotek .NET Framework są dystrybuowane z pakietami docelowymi.</span><span class="sxs-lookup"><span data-stu-id="10022-122">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="10022-123">Można je uzyskać, pobierając Autonomiczny Instalator lub wybierając składnik w Instalatorze programu Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="10022-123">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="10022-124">Aby uzyskać więcej informacji, zobacz [Install the .NET Framework for Developers](../../framework/install/guide-for-developers.md).</span><span class="sxs-lookup"><span data-stu-id="10022-124">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="10022-125">W przypadku platformy .NET Core i .NET Standard zestawy odwołań są automatycznie pobierane zgodnie z potrzebami (za pośrednictwem NuGet) i przywoływane.</span><span class="sxs-lookup"><span data-stu-id="10022-125">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="10022-126">W przypadku platformy .NET Core 3,0 lub nowszej zestawy referencyjne dla podstawowej platformy są w pakiecie [Microsoft. servicecore. app. ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) (w zamian jest używany pakiet [Microsoft. servicecore. app](https://www.nuget.org/packages/Microsoft.NETCore.App) ) dla wersji przed 3,0.</span><span class="sxs-lookup"><span data-stu-id="10022-126">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="10022-127">Aby uzyskać więcej informacji, zobacz [pakiety, aplikacje i struktury](../../core/packages.md) w przewodniku .NET Core.</span><span class="sxs-lookup"><span data-stu-id="10022-127">For more information, see [Packages, metapackages and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="10022-128">Po dodaniu odwołań do zestawów .NET Framework w programie Visual Studio przy użyciu okna dialogowego **Dodawanie odwołania** można wybrać zestaw z listy, a program Visual Studio automatycznie odnajdzie zestawy referencyjne odpowiadające wersji platformy docelowej wybrane w projekcie.</span><span class="sxs-lookup"><span data-stu-id="10022-128">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="10022-129">To samo dotyczy dodawania odwołań bezpośrednio do projektu MSBuild przy użyciu elementu projektu [referencyjnego](/visualstudio/msbuild/common-msbuild-project-items#reference) : należy określić tylko nazwę zestawu, a nie pełną ścieżkę pliku.</span><span class="sxs-lookup"><span data-stu-id="10022-129">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="10022-130">Po dodaniu odwołań do tych zestawów w wierszu polecenia przy użyciu opcji kompilatora `-reference` ([w C# ](../../csharp/language-reference/compiler-options/reference-compiler-option.md) i w [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) lub przy użyciu metody <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> w interfejsie API Roslyn należy ręcznie określić pliki zestawu odwołań dla poprawna wersja platformy docelowej.</span><span class="sxs-lookup"><span data-stu-id="10022-130">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="10022-131">Pliki zestawów odwołań .NET Framework znajdują się w *zestawach% ProgramFiles (x86)% \\Reference \\Microsoft \\Framework \\. NETFramework* .</span><span class="sxs-lookup"><span data-stu-id="10022-131">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="10022-132">W przypadku platformy .NET Core można wymusić operację publikowania, aby skopiować zestawy referencyjne dla platformy docelowej do podkatalogu *Publish/ReFS* w katalogu wyjściowym przez ustawienie właściwości projektu `PreserveCompilationContext` na `true`.</span><span class="sxs-lookup"><span data-stu-id="10022-132">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="10022-133">Następnie można przekazać te pliki zestawu odwołań do kompilatora.</span><span class="sxs-lookup"><span data-stu-id="10022-133">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="10022-134">Używanie `DependencyContext` z pakietu [Microsoft. Extensions. DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) może pomóc w znalezieniu ich ścieżek.</span><span class="sxs-lookup"><span data-stu-id="10022-134">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="10022-135">Ponieważ nie zawierają one implementacji, nie można załadować zestawów odwołań do wykonania; podjęto próbę wykonania tej czynności w <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10022-135">Because they contain no implementation, reference assemblies cannot be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="10022-136">Jednak nadal mogą być ładowane do kontekstu tylko odbicie (przy użyciu <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>), jeśli trzeba będzie przeanalizować ich zawartość.</span><span class="sxs-lookup"><span data-stu-id="10022-136">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>) method, if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="10022-137">Generowanie zestawów referencyjnych</span><span class="sxs-lookup"><span data-stu-id="10022-137">Generating reference assemblies</span></span>

<span data-ttu-id="10022-138">Generowanie zestawów referencyjnych dla bibliotek może być przydatne, gdy klienci biblioteki często muszą kompilować swoje programy w wielu różnych wersjach biblioteki (to jest, gdy zachodzi potrzeba wdrożenia funkcji podobnej do .NET Framework pakietów docelowych wymienione powyżej dla własnego projektu).</span><span class="sxs-lookup"><span data-stu-id="10022-138">Generating reference assemblies for your libraries can be useful when your library consumers often need to build their programs against many different versions of the library (that is, when you need to implement a feature similar to .NET Framework Targeting Packs mentioned above for your own project).</span></span> <span data-ttu-id="10022-139">Dystrybuowanie zestawów implementacji dla wszystkich tych wersji może być niepraktyczne ze względu na ich duży rozmiar.</span><span class="sxs-lookup"><span data-stu-id="10022-139">Distributing implementation assemblies for all these versions might be impractical due to their large size.</span></span> <span data-ttu-id="10022-140">Zestawy referencyjne są mniejsze w rozmiarze, więc dystrybuowanie ich jako części zestawu SDK biblioteki zmniejsza rozmiar pobierania i oszczędza miejsce na dysku.</span><span class="sxs-lookup"><span data-stu-id="10022-140">Reference assemblies are smaller in size, so distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="10022-141">Narzędzia środowisk IDE i Build Tools mogą również korzystać z zestawów referencyjnych, aby skrócić czasy kompilacji w przypadku dużych rozwiązań składających się z wielu bibliotek klas.</span><span class="sxs-lookup"><span data-stu-id="10022-141">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="10022-142">Zwykle w scenariuszach kompilacji przyrostowej projekt jest odbudowany, gdy którykolwiek z jego plików wejściowych zostanie zmieniony, włącznie z zestawami, od których zależy.</span><span class="sxs-lookup"><span data-stu-id="10022-142">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="10022-143">Zestaw implementacji zmienia się za każdym razem, gdy programista zmieni implementację dowolnego elementu członkowskiego.</span><span class="sxs-lookup"><span data-stu-id="10022-143">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="10022-144">Zestaw referencyjny zmienia się tylko wtedy, gdy jego publiczny interfejs API ma wartość.</span><span class="sxs-lookup"><span data-stu-id="10022-144">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="10022-145">W związku z tym, użycie zestawu odwołania jako pliku wejściowego zamiast zestawu implementacji pozwala pominąć kompilację zależnego projektu w niektórych przypadkach.</span><span class="sxs-lookup"><span data-stu-id="10022-145">Therefore, using the reference assembly as an input file instead of the implementation assembly allows to skip the build of the dependent project in some cases.</span></span> 

<span data-ttu-id="10022-146">Można generować zestawy referencyjne:</span><span class="sxs-lookup"><span data-stu-id="10022-146">You can generate reference assemblies:</span></span>

- <span data-ttu-id="10022-147">W projekcie MSBuild, przy użyciu [właściwości projektu `ProduceReferenceAssembly`](/visualstudio/msbuild/common-msbuild-project-properties).</span><span class="sxs-lookup"><span data-stu-id="10022-147">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="10022-148">Podczas kompilowania programu z wiersza polecenia, przez specifiying `-refonly`[( C#w ](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) lub `-refout` ([ C#w ](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [w Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) opcji kompilatora.</span><span class="sxs-lookup"><span data-stu-id="10022-148">When compiling program from command line, by specifiying `-refonly` ([in C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([in C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="10022-149">W przypadku korzystania z interfejsu API Roslyn przez ustawienie <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> na `true` i <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> do `false` w obiekcie przekazaną do metody <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="10022-149">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="10022-150">Jeśli chcesz dystrybuować zestawy referencyjne z pakietami NuGet, musisz uwzględnić je w podkatalogu *ref \\* w katalogu pakietu, a nie w podkatalogu *lib \\* używanym do zestawów implementacji.</span><span class="sxs-lookup"><span data-stu-id="10022-150">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="10022-151">Struktura zestawów odwołań</span><span class="sxs-lookup"><span data-stu-id="10022-151">Reference assemblies structure</span></span>

<span data-ttu-id="10022-152">Zestawy referencyjne są rozwinięciem powiązanej koncepcji, *zestawów samych metadanych*.</span><span class="sxs-lookup"><span data-stu-id="10022-152">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="10022-153">Zestawy zawierające tylko metadane są zastępowane przez jedną `throw null` treść, ale obejmują wszystkie elementy członkowskie z wyjątkiem typów anonimowych.</span><span class="sxs-lookup"><span data-stu-id="10022-153">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="10022-154">Powód używania `throw null`ych treści (w przeciwieństwie do braku treści) polega na tym, że PEVerify może działać i przekazywać (w związku z tym sprawdzanie kompletności metadanych).</span><span class="sxs-lookup"><span data-stu-id="10022-154">The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="10022-155">Zestawy referencyjne usuwają metadane (prywatne składowe) z zestawów samych metadanych:</span><span class="sxs-lookup"><span data-stu-id="10022-155">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="10022-156">Zestaw odniesienia zawiera odwołania do potrzebnych elementów interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="10022-156">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="10022-157">Rzeczywisty zestaw może zawierać dodatkowe odwołania dotyczące konkretnych implementacji.</span><span class="sxs-lookup"><span data-stu-id="10022-157">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="10022-158">Na przykład zestaw odwołania dla `class C { private void M() { dynamic d = 1; ... } }` nie odwołuje się do żadnego typu wymaganego dla `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="10022-158">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="10022-159">Prywatne funkcje — elementy członkowskie (metody, właściwości i zdarzenia) są usuwane w przypadkach, gdy ich usunięcie nie ma zauważalnego wpływu na kompilację.</span><span class="sxs-lookup"><span data-stu-id="10022-159">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="10022-160">Jeśli nie ma żadnych atrybutów [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) , składowe funkcji wewnętrznych również są usuwane.</span><span class="sxs-lookup"><span data-stu-id="10022-160">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="10022-161">Metadane w zestawach referencyjnych nadal zachowują informacje o następujących kwestiach:</span><span class="sxs-lookup"><span data-stu-id="10022-161">The metadata in reference assemblies continues to retain information about the following:</span></span>

- <span data-ttu-id="10022-162">Wszystkie typy, w tym typy prywatne i zagnieżdżone.</span><span class="sxs-lookup"><span data-stu-id="10022-162">All types, including private and nested types.</span></span>
- <span data-ttu-id="10022-163">Wszystkie atrybuty, nawet wewnętrzne.</span><span class="sxs-lookup"><span data-stu-id="10022-163">All attributes, even internal ones.</span></span>
- <span data-ttu-id="10022-164">Wszystkie metody wirtualne.</span><span class="sxs-lookup"><span data-stu-id="10022-164">All virtual methods.</span></span>
- <span data-ttu-id="10022-165">Jawne implementacje interfejsu.</span><span class="sxs-lookup"><span data-stu-id="10022-165">Explicit interface implementations.</span></span> 
- <span data-ttu-id="10022-166">Jawnie zaimplementowane właściwości i zdarzenia, ponieważ ich metody dostępu są wirtualne.</span><span class="sxs-lookup"><span data-stu-id="10022-166">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="10022-167">Wszystkie pola struktur.</span><span class="sxs-lookup"><span data-stu-id="10022-167">All fields of structures.</span></span> 

<span data-ttu-id="10022-168">Zestawy referencyjne zawierają atrybut [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) na poziomie zestawu.</span><span class="sxs-lookup"><span data-stu-id="10022-168">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="10022-169">Ten atrybut może być określony w źródle; Następnie kompilator nie będzie musiał go przeprowadzić.</span><span class="sxs-lookup"><span data-stu-id="10022-169">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="10022-170">Ze względu na ten atrybut środowiska uruchomieniowe będą odrzucać ładowanie zestawów odwołań do wykonania (ale nadal mogą być ładowane w trybie tylko odbicie).</span><span class="sxs-lookup"><span data-stu-id="10022-170">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode).</span></span>

<span data-ttu-id="10022-171">Dokładne szczegóły struktury zestawu odwołań zależą od wersji kompilatora.</span><span class="sxs-lookup"><span data-stu-id="10022-171">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="10022-172">Nowsze wersje mogą zdecydować się na wykluczenie większej liczby metadanych, jeśli zostanie ona określona jako nie wpływająca na publiczną powierzchnię interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="10022-172">Newer versions may choose to exclude more metadata if it is determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="10022-173">Informacje w tej sekcji dotyczą tylko zestawów referencyjnych wygenerowanych przez kompilatory Roslyn zaczynające się od C# wersji 7,1 lub Visual Basic wersji 15,3.</span><span class="sxs-lookup"><span data-stu-id="10022-173">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="10022-174">Struktura zestawów referencyjnych dla bibliotek .NET Framework i .NET Core może różnić się w niektórych szczegółach, ponieważ korzystają z własnego mechanizmu generowania zestawów odwołań.</span><span class="sxs-lookup"><span data-stu-id="10022-174">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="10022-175">Na przykład mogą mieć całkowicie puste treści metody zamiast treści `throw null`.</span><span class="sxs-lookup"><span data-stu-id="10022-175">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="10022-176">Jednak ogólna zasada nadal stosuje się: nie mają one przydatnych implementacji metod i zawierają tylko metadane dla elementów członkowskich, które mają zauważalny wpływ z perspektywy publicznego interfejsu API.</span><span class="sxs-lookup"><span data-stu-id="10022-176">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="10022-177">Zobacz także</span><span class="sxs-lookup"><span data-stu-id="10022-177">See also</span></span>

- [<span data-ttu-id="10022-178">Zestawy w środowisku .NET</span><span class="sxs-lookup"><span data-stu-id="10022-178">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="10022-179">Program z zestawami</span><span class="sxs-lookup"><span data-stu-id="10022-179">Program with assemblies</span></span>](program.md)
- [<span data-ttu-id="10022-180">Omówienie określania celu platformy</span><span class="sxs-lookup"><span data-stu-id="10022-180">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="10022-181">Instrukcje: Dodawanie lub usuwanie odwołań za pomocą Menedżera odwołań</span><span class="sxs-lookup"><span data-stu-id="10022-181">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
